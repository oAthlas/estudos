Django é um framework para criação do backend de aplicações web, sites em geral. Seu principal diferencial são seus incontáveis módulos prontos para diversas tarefas comuns em sites, como painel administrativo, envio de formulários, sistema de login e autenticação, etc. Usa SQLite como db padrão o que o torna bastante light, claro, com capacidade para utilizar outro db caso necessário.

Para começar um projeto em django primeiro o instale na máquina através do pip install django, espere a instalação concluir e já está  pronto para começar os projetos. O Django em si não tem uma interface, os primeiros passos sempre são feitos via terminal. Crie uma pasta para a raiz do projeto e abre ela com o terminal, neste terminal execute o comando django-admin startproject <nome do projeto> para criar o projeto em si.

Uma vez dentro do projeto terá a pasta raiz + o arquivo manage.py, o mesmo é o responsável por executar todos os comandos da aplicação em si, bem como o comando de iniciar o servidor em si: python manage.py runserver. Toda e qualquer ação envolvendo a aplicação terá o python manage.py como prefixo. De inicio, se importe apenas com a pasta de módulos do Django.

init.py, wsgi.py e __init__.py são módulos de controle e segurança web e não influenciam na criação de nenhum projeto. O mais importante é o settings.py e urls.py.
Django é um framework de produção backend que foca em modularização e multiconfigurações. Cada arquivo é responsável por cada ínfima coisa.
Settings.py é o arquivo principal do projeto com todas as especificações e configurações, na parte inicial temos os apps importados, e os módulos, abaixo mais algumas áreas de configurações do próprio Python, o mais importante nessas seções mais escondidas é o caminho de diretórios para templates, que não tem nada por padrão e é importante defini-lo como /templates, com isso ele procura a partir da raiz de cada app pela pasta templates, abordarei sobre os templates posteriormente.  Outra coisa importante aqui é o fuso horário e o idioma, se a configuração estiver como vem na instalação estará tudo em inglês com fusos americanos também, para mudar basta mudar o campo de linguagem para pt-br e o campo de fuso horário para America/Sao_Paulo. Uma configuração interessante para se ressaltar é a DEBUG, quando ligada (True) ela ativa a página de debug de erros no próprio navegador, é estritamente obrigatório desligar (False) esta configuração quando a aplicação entrar em produção.

Sobre o urls.py, é onde as rotas dos apps são definidas, como disse anteriormente, cada arquivo do Django faz algo distinto e é passível de configurações, por padrão o único caminho ali é o console de admin (abordarei depois). Algo que gera muita confusão entre iniciante é o fato deste arquivo carregar as urls DO PROJETO e não as urls do site em si, isso é dinâmico e o Django como um todo é responsável por isso, aqui seria como um arquivo de rotas. Utilizando o path e deixando o primeiro valor nulo podemos usar o include para incluir as urls dos nossos apps aqui, essas sim são boa parte da configuração dos urls do site. É simples a utilidade deste arquivo, mas confunde bastante quem não tem familiaridade com a stack por conta da existência de outros urls.py ao decorrer do projeto.

Agora vamos para a parte mais interessante do django, os apps... No Django os "módulos" de páginas, funções e qualquer outra coisa que realize tarefas são chamados de Apps, eles são feitos a partir do comando python manage.py startapp <nome do app> e sempre devem ser carregados na parte de INSTALLED_APPS no settings.py para que o Django o reconheça. Após executar o comando de startapp o Django irá criar uma pasta na mesma raiz do manage.py com alguns arquivos já prontos, o tests.py e o __init__.py não são de grande importância agora, o apps.py contém a classe de configuração do app. O Django usa essa classe quando você registra o app no INSTALLED_APPS. Ele não adiciona o app automaticamente ao settings, mas define metadados e comportamentos do app.

Vamos começar pelo melhor, essa parte é um pouco confusa pois tudo dentro de um app do Django se complementa, mas vamos do inicio, o models.py, o arquivo mais "interessante" do app, ele é o responsável por definir nossas colunas do banco de dados. Assim como qualquer stack backend, o Django lida com banco de dados e quem cria as listas é o models.py. Criamos uma classe que representa uma tabela do banco de dados, com campos correspondendo às colunas. Uma vez com nossa classe criada usamos o comando python manage.py makemigrations para gerar  o arquivo contendo as migrações do app para o banco de dados, esse arquivo é editável e fica na pasta migrations dentro da pasta do app, após esse arquivo criado usamos o comando python manage.py migrate para aplicar as mudanças ao banco de dados e isso gera o arquivo db.sqlite do projeto, esse é o banco de dados. Percebe que isso de makemigrations gerando um arquivo editável e o migrate aplicando as mudanças ao banco de dados é bem parecido com o sistema de versionamento que temos no GitHub? Gosto de pensar que foi inspirado nele ou que pelo menos segue a mesma lógica, como um versionamento de banco de dados.

Com as colunas necessárias do banco de dados criadas podemos partir para o views.py e o urls.py que não podem ser explicados separadamente pois são completamente complementares um ao outro. O views.py é o arquivo principal do nosso app, é nele que vão as funções e toda a lógica do site: Cria-se uma função (def) com um parâmetro de ação, geralmente o request, e usa-se o return para acionar as coisas, render também é bastante usando quando se trata de mostrar páginas HTML. O views.py é carregado pelo urls.py e pode parecer estranho caso seja sua primeira vez tendo contato com o Django já que este arquivo não está na pasta logo ao criar o app com o startapp, ele é criado por nós, algumas configurações do Django são opcionais (outro bom exemplo disso é o forms, não vou me aprofundar no momento), mas o urls.py dos apps é praticamente obrigatório em todos os projetos, sua função é criar um caminho de url com uma função listada no views.py e nomear a junção dessas duas coisas. Lembra do urls.py da pasta principal do projeto? É lá que as urls.py de cada app é mencionada e carregada de forma dinâmica.

Agora vamos para a parte onde colocaremos alguns códigos no frontend, os templates. Templates no Django nada mais são do que as próprias páginas em HTML que compõem o nosso site, elas são inseridas em projeto/app/templates se você configurou o DIRS no settings.py anteriormente. Aqui vão as páginas em HTML do site, mas há algumas coisas importantes a se ressaltar sobre isso pois HTML se comporta diferente do usual quando usado em Django, no Django é possível usar funções do próprio Python dentro do HTML e isso abre um mar de possibilidades. Ao usar {{}} (chaves duplas) dentro do HTML mencionamos variáveis e ao usar {%%} (chaves duplas com dupla porcentagem) mencionamos comando. variáveis são bastante usadas para mencionar tags do próprio Django e os comandos são usados tanto para carregar os arquivos contendo variáveis externas quanto por funções no próprio HTML, uma muito comum é o for para listagens. Agora é importante saber pelo menos onde referenciá-las para serem exibidas.

Seguindo a lógica normal das coisas você iria querer apontar a sua url diretamente para o seu arquivo HTML, porém o Django torna tudo absurdamente dinâmico... Se urls.py do projeto cria o projeto e aponta para uma função do views.py então é nessa função que temos que chamar nosso HTML, como disse anteriormente, usa-se o parâmetro request para fazer uma requisição e a função em si usa um return (para retornar algo) render (uma função própria para chamar respostas http) que carrega nosso arquivo html, lembrando sempre de colocar o request como parametro da resposta para o a lógica entender o que está fazendo.

Uma vez com o fluxo todo montado e configurado é só usar o comando python manage.py runserver para iniciar o servidor, ele abre em 127.0.0.1:8000 ou localhost:8000 e uma vez com o link aberto você verá apenas uma tela de debug (por que deixamos o DEBUG como True antes) com os caminhos existentes no seu projeto. Temos por padrão o admin e a rota que configuramos. Ao acessar você verá o conteúdo do HTML e mais nada pois não temos mais nada configurado, no nosso caso o fluxo segue o seguinte: manage.py inicia o servidor, uma vez na home você os caminhos disponíveis pois não há nada configurado para o caminho principal: Tentamos acessar uma página e o Django procura nas urls.py (do projeto) as urls.py dos apps listados, se a url que estamos tentando acessar existir em algum dos urls.py listados no urls.py principal então ele executa a  função do views.py que no nosso caso é uma função que chama um HTML: Se não encontrar ele cai no 404 por que não há rota configurada para a url que tentamos acessar.

Finalizarei a explicação básica do Django falando sobre o modelo MTV do Django que equivale ao MVC. Modelos no quesito web são a ordem, o fluxo das coisas, o padrão conhecido é o MVC que significa Model > View > Controller, onde Model são os modelos, Views é o visual e Controller é a lógica que une os dois. No Django esse conceito foi renomeado devido a forma como as coisas funcionam nele, chamamos de MTV: Model > Template > Views, percebe que é basicamente a mesma coisa, porém renomeada? O Model continua sendo os models, o template equivale ao HTML, ou seja, o apresentável, e a Views é o views do Django que representa a lógica. É uma das peculiaridades do Django.
