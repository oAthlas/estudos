Django é um framework para criação do backend de aplicações web, sites em geral. Seu principal diferencial são seus incontáveis módulos prontos para diversas tarefas comuns em sites, como painel administrativo, envio de formulários, sistema de login e autenticação, etc. Usa <code>SQLite</code> como db padrão o que o torna bastante light, claro, com capacidade para utilizar outro db caso necessário.

Para começar um projeto em django primeiro o instale na máquina através do <code>pip install django</code>, espere a instalação concluir e já está pronto para começar os projetos. O Django em si não tem uma interface, os primeiros passos sempre são feitos via terminal. Crie uma pasta para a raiz do projeto e abra ela com o terminal, neste terminal execute o comando <code>django-admin startproject nome_do_projeto</code> para criar o projeto em si.

Uma vez dentro do projeto terá a pasta raiz + o arquivo <code>manage.py</code>, o mesmo é o responsável por executar todos os comandos da aplicação em si, bem como o comando de iniciar o servidor em si: <code>python manage.py runserver</code>. Toda e qualquer ação envolvendo a aplicação terá o <code>python manage.py</code> como prefixo. De inicio, se importe apenas com a pasta de módulos do Django.

<code>init.py</code>, <code>wsgi.py</code> e <code>init.py</code> são módulos de controle e segurança web e não influenciam na criação de nenhum projeto. O mais importante é o <code>settings.py</code> e <code>urls.py</code>.
Django é um framework de produção backend que foca em modularização e multiconfigurações. Cada arquivo é responsável por cada ínfima coisa.
<code>Settings.py</code> é o arquivo principal do projeto com todas as especificações e configurações, na parte inicial temos os apps importados, e os módulos, abaixo mais algumas áreas de configurações do próprio Python, o mais importante nessas seções mais escondidas é o caminho de diretórios para templates, que não tem nada por padrão e é importante defini-lo como <code>/templates</code>, com isso ele procura a partir da raiz de cada app pela pasta <code>templates</code>, abordarei sobre os templates posteriormente. Outra coisa importante aqui é o fuso horário e o idioma, se a configuração estiver como vem na instalação estará tudo em inglês com fusos americanos também, para mudar basta mudar o campo de linguagem para <code>pt-br</code> e o campo de fuso horário para <code>America/Sao_Paulo</code>. Uma configuração interessante para se ressaltar é a <code>DEBUG</code>, quando ligada (<code>True</code>) ela ativa a página de debug de erros no próprio navegador, é estritamente obrigatório desligar (<code>False</code>) esta configuração quando a aplicação entrar em produção.

Sobre o <code>urls.py</code>, é onde as rotas dos apps são definidas, como disse anteriormente, cada arquivo do Django faz algo distinto e é passível de configurações, por padrão o único caminho ali é o console de admin (abordarei depois). Algo que gera muita confusão entre iniciantes é o fato deste arquivo carregar as urls DO PROJETO e não as urls do site em si, isso é dinâmico e o Django como um todo é responsável por isso, aqui seria como um arquivo de rotas. Utilizando o <code>path</code> e deixando o primeiro valor nulo podemos usar o <code>include</code> para incluir as urls dos nossos apps aqui, essas sim são boa parte da configuração dos urls do site. É simples a utilidade deste arquivo, mas confunde bastante quem não tem familiaridade com a stack por conta da existência de outros <code>urls.py</code> ao decorrer do projeto.

Agora vamos para a parte mais interessante do django, os apps... No Django os "módulos" de páginas, funções e qualquer outra coisa que realize tarefas são chamados de Apps, eles são feitos a partir do comando <code>python manage.py startapp nome_do_app</code> e sempre devem ser carregados na parte de <code>INSTALLED_APPS</code> no <code>settings.py</code> para que o Django o reconheça. Após executar o comando de startapp o Django irá criar uma pasta na mesma raiz do <code>manage.py</code> com alguns arquivos já prontos, o <code>tests.py</code> e o <code>init.py</code> não são de grande importância agora, o <code>apps.py</code> contém a classe de configuração do app. O Django usa essa classe quando você registra o app no <code>INSTALLED_APPS</code>. Ele não adiciona o app automaticamente ao settings, mas define metadados e comportamentos do app.

Vamos começar pelo melhor, essa parte é um pouco confusa pois tudo dentro de um app do Django se complementa, mas vamos do inicio, o <code>models.py</code>, o arquivo mais "interessante" do app, ele é o responsável por definir nossas colunas do banco de dados. Assim como qualquer stack backend, o Django lida com banco de dados e quem cria as listas é o <code>models.py</code>. Criamos uma classe que representa uma tabela do banco de dados, com campos correspondendo às colunas. Uma vez com nossa classe criada usamos o comando <code>python manage.py makemigrations</code> para gerar o arquivo contendo as migrações do app para o banco de dados, esse arquivo é editável e fica na pasta <code>migrations</code> dentro da pasta do app, após esse arquivo criado usamos o comando <code>python manage.py migrate</code> para aplicar as mudanças ao banco de dados e isso gera o arquivo <code>db.sqlite</code> do projeto, esse é o banco de dados. Percebe que isso de makemigrations gerando um arquivo editável e o migrate aplicando as mudanças ao banco de dados é bem parecido com o sistema de versionamento que temos no GitHub? Gosto de pensar que foi inspirado nele ou que pelo menos segue a mesma lógica, como um versionamento de banco de dados.

Com as colunas necessárias do banco de dados criadas podemos partir para o <code>views.py</code> e o <code>urls.py</code> que não podem ser explicados separadamente pois são completamente complementares um ao outro. O <code>views.py</code> é o arquivo principal do nosso app, é nele que vão as funções e toda a lógica do site: Cria-se uma função (<code>def</code>) com um parâmetro de ação, geralmente o <code>request</code>, e usa-se o <code>return</code> para acionar as coisas, <code>render</code> também é bastante usando quando se trata de mostrar páginas HTML. O <code>views.py</code> é carregado pelo <code>urls.py</code> e pode parecer estranho caso seja sua primeira vez tendo contato com o Django já que este arquivo não está na pasta logo ao criar o app com o startapp, ele é criado por nós, algumas configurações do Django são opcionais (outro bom exemplo disso é o <code>forms</code>, não vou me aprofundar no momento), mas o <code>urls.py</code> dos apps é praticamente obrigatório em todos os projetos, sua função é criar um caminho de url com uma função listada no <code>views.py</code> e nomear a junção dessas duas coisas. Lembra do <code>urls.py</code> da pasta principal do projeto? É lá que as <code>urls.py</code> de cada app é mencionada e carregada de forma dinâmica.

Agora vamos para a parte onde colocaremos alguns códigos no frontend, os templates. Templates no Django nada mais são do que as próprias páginas em HTML que compõem o nosso site, elas são inseridas em <code>projeto/app/templates</code> se você configurou o <code>DIRS</code> no <code>settings.py</code> anteriormente. Aqui vão as páginas em HTML do site, mas há algumas coisas importantes a se ressaltar sobre isso pois HTML se comporta diferente do usual quando usado em Django, no Django é possível usar funções do próprio Python dentro do HTML e isso abre um mar de possibilidades. Ao usar <code>{{}}</code> (chaves duplas) dentro do HTML mencionamos variáveis e ao usar <code>{%%}</code> (chaves duplas com dupla porcentagem) mencionamos comandos. Variáveis são bastante usadas para mencionar tags do próprio Django e os comandos são usados tanto para carregar os arquivos contendo variáveis externas quanto por funções no próprio HTML, uma muito comum é o <code>for</code> para listagens. Agora é importante saber pelo menos onde referenciá-las para serem exibidas.

Seguindo a lógica normal das coisas você iria querer apontar a sua url diretamente para o seu arquivo HTML, porém o Django torna tudo absurdamente dinâmico... Se <code>urls.py</code> do projeto cria o projeto e aponta para uma função do <code>views.py</code> então é nessa função que temos que chamar nosso HTML, como disse anteriormente, usa-se o parâmetro <code>request</code> para fazer uma requisição e a função em si usa um <code>return</code> (para retornar algo) <code>render</code> (uma função própria para chamar respostas http) que carrega nosso arquivo html, lembrando sempre de colocar o <code>request</code> como parametro da resposta para o a lógica entender o que está fazendo.

Uma vez com o fluxo todo montado e configurado é só usar o comando <code>python manage.py runserver</code> para iniciar o servidor, ele abre em <code>127.0.0.1:8000</code> ou <code>localhost:8000</code> e uma vez com o link aberto você verá apenas uma tela de debug (por que deixamos o <code>DEBUG</code> como <code>True</code> antes) com os caminhos existentes no seu projeto. Temos por padrão o admin e a rota que configuramos. Ao acessar você verá o conteúdo do HTML e mais nada pois não temos mais nada configurado, no nosso caso o fluxo segue o seguinte: <code>manage.py</code> inicia o servidor, uma vez na home você vê os caminhos disponíveis pois não há nada configurado para o caminho principal: Tentamos acessar uma página e o Django procura nas <code>urls.py</code> (do projeto) as <code>urls.py</code> dos apps listados, se a url que estamos tentando acessar existir em algum dos <code>urls.py</code> listados no <code>urls.py</code> principal então ele executa a função do <code>views.py</code> que no nosso caso é uma função que chama um HTML: Se não encontrar ele cai no 404 por que não há rota configurada para a url que tentamos acessar.

Finalizarei a explicação básica do Django falando sobre o modelo <code>MTV</code> do Django que equivale ao <code>MVC</code>. Modelos no quesito web são a ordem, o fluxo das coisas, o padrão conhecido é o <code>MVC</code> que significa <code>Model > View > Controller</code>, onde <code>Model</code> são os modelos, <code>Views</code> é o visual e <code>Controller</code> é a lógica que une os dois. No Django esse conceito foi renomeado devido a forma como as coisas funcionam nele, chamamos de <code>MTV</code>: <code>Model > Template > Views</code>, percebe que é basicamente a mesma coisa, porém renomeada? O <code>Model</code> continua sendo os models, o template equivale ao HTML, ou seja, o apresentável, e a <code>Views</code> é o <code>views</code> do Django que representa a lógica. É uma das peculiaridades do Django.
